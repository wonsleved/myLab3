#ifndef MYLAB3_BINARYTREE_H
#define MYLAB3_BINARYTREE_H

#include <iostream>
#include <vector>
#include <string>
#include <sstream>
#include <random>
#include <functional>
#include "../Exceptions/Exceptions.h"

using std::vector;
using std::string;
using std::cout;

template <class T>
class BinaryTree
{
private:
    using M_Node = struct M_Node {
        T data;
        M_Node* leftChild;
        M_Node* rightChild;
        M_Node* parent;

        M_Node();
        M_Node(M_Node* parent, const T& data);
        ~M_Node();

        int maxDepth() const;
    };

    M_Node* m_root;
public:
    BinaryTree();
    BinaryTree(T item);
    BinaryTree(T* items, int count);
    BinaryTree(BinaryTree<T>& another);

    ~BinaryTree();


    M_Node* getNode(T& item);
    bool searchItem(T& item);
    bool searchItem(T&& item);
    bool searchTree(BinaryTree<T>& source);
    BinaryTree<T>& insert(T& item);
    BinaryTree<T>& insert(T&& item);
    BinaryTree<T>* remove(T& item);
    BinaryTree<T>* remove(T&& item);
    BinaryTree<T>* map(T (*function)(const T& item));
    BinaryTree<T>* filter(bool (*function)(const T& item));
    BinaryTree<T>* cutTree(T& item);
    T reduce(T (*function)(const T& previousValue, const T& currentValue));

    const M_Node& getRoot();
    int getMaxDepth() const;

private:
    BinaryTree<T>& insert(M_Node* node, M_Node* parent, T& item);
    M_Node* getLocalMax(M_Node* root);
    bool searchTreeDev(M_Node* destinationRoot, M_Node* sourceRoot);
    BinaryTree<T>& removeNode(M_Node* target);
    BinaryTree<T>& preOrderTravers(const M_Node* nodeRoot, std::function<void(T)> func);
    M_Node* rightRotate(M_Node* y);
    M_Node* leftRotate(M_Node* x);
    int getBalance(M_Node* Node);

//
//          OUTPUT
//

private:

    struct cellDisplay {
        string   valstr;
        bool     present;
        cellDisplay() : present(false) {};
        cellDisplay(std::string valstr) : valstr(valstr), present(true) {};
    };

    using displayRows = vector< vector< cellDisplay > >;
// The text tree generation code below is all iterative, to avoid stack faults.

// getRowDisplay builds a vector of vectors of cell_display structs
// each vector of cell_display structs represents one row, starting at the root
    displayRows getRowDisplay() const;

// rowFormatter takes the vector of rows of cell_display structs
// generated by getRowDisplay and formats it into a test representation
// as a vector of strings
    vector<string> rowFormatter(const displayRows& rowsDisp) const;

// Trims an equal number of space characters from
// the beginning of each string in the vector.
// At least one string in the vector will end up beginning
// with no space characters.
    static void trimRowsLeft(vector<string>& rows);
public:
// Dumps a representation of the tree to cout
    std::ostream& Dump(std::ostream& out) const;
};




#include "BinaryTree.inl"

#endif
